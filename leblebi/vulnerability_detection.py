"""Vulnerability detection and analysis module for Leblebi

This module provides vulnerability detection capabilities using
Wazuh API and SCA (Security Configuration Assessment) data.
"""

from typing import Dict, List, Any, Optional
from collections import defaultdict
from datetime import datetime
from leblebi.wazuh_api import WazuhAPI


class VulnerabilityDetector:
    """Detect and analyze vulnerabilities from Wazuh data"""
    
    def __init__(self, api_client: Optional[WazuhAPI] = None):
        """Initialize vulnerability detector
        
        Args:
            api_client: WazuhAPI instance for fetching vulnerability data
        """
        self.api = api_client
        self.enabled = api_client is not None
    
    def get_vulnerability_summary(self, agents: List[Dict]) -> Dict[str, Any]:
        """Get vulnerability summary across all agents
        
        Args:
            agents: List of agent dictionaries
            
        Returns:
            Dictionary with vulnerability summary statistics
        """
        if not self.enabled or not agents:
            return {
                'enabled': False,
                'total_agents_checked': 0,
                'agents_with_vulnerabilities': 0,
                'total_vulnerabilities': 0,
                'critical_vulnerabilities': 0,
                'high_vulnerabilities': 0,
                'medium_vulnerabilities': 0,
                'low_vulnerabilities': 0
            }
        
        summary = {
            'enabled': True,
            'total_agents_checked': 0,
            'agents_with_vulnerabilities': 0,
            'total_vulnerabilities': 0,
            'critical_vulnerabilities': 0,
            'high_vulnerabilities': 0,
            'medium_vulnerabilities': 0,
            'low_vulnerabilities': 0,
            'vulnerabilities_by_agent': []
        }
        
        for agent in agents:
            agent_id = str(agent.get('id', ''))
            if not agent_id:
                continue
            
            try:
                # Get SCA results for agent
                sca_results = self.api.get_sca_results(agent_id=agent_id, limit=100)
                
                if sca_results:
                    summary['total_agents_checked'] += 1
                    
                    agent_vulns = {
                        'agent_id': agent_id,
                        'agent_name': agent.get('name', 'N/A'),
                        'policies': [],
                        'total_failed_checks': 0,
                        'total_passed_checks': 0
                    }
                    
                    for policy in sca_results:
                        policy_name = policy.get('name', 'N/A')
                        failed_checks = policy.get('fail', 0)
                        passed_checks = policy.get('pass', 0)
                        not_checked = policy.get('notchecked', 0)
                        
                        agent_vulns['total_failed_checks'] += failed_checks
                        agent_vulns['total_passed_checks'] += passed_checks
                        
                        if failed_checks > 0:
                            summary['agents_with_vulnerabilities'] += 1
                            summary['total_vulnerabilities'] += failed_checks
                            
                            # Categorize by severity (SCA policies typically have severity)
                            # We'll use failed checks count as a proxy for severity
                            if failed_checks >= 10:
                                summary['critical_vulnerabilities'] += failed_checks
                            elif failed_checks >= 5:
                                summary['high_vulnerabilities'] += failed_checks
                            elif failed_checks >= 2:
                                summary['medium_vulnerabilities'] += failed_checks
                            else:
                                summary['low_vulnerabilities'] += failed_checks
                            
                            agent_vulns['policies'].append({
                                'name': policy_name,
                                'failed_checks': failed_checks,
                                'passed_checks': passed_checks,
                                'not_checked': not_checked
                            })
                    
                    if agent_vulns['total_failed_checks'] > 0:
                        summary['vulnerabilities_by_agent'].append(agent_vulns)
                        
            except Exception:
                # Skip agent if error occurs
                continue
        
        # Sort by total vulnerabilities (most critical first)
        summary['vulnerabilities_by_agent'].sort(
            key=lambda x: x['total_failed_checks'], 
            reverse=True
        )
        
        return summary
    
    def get_cve_alerts_from_alerts(self, alerts: List[Dict]) -> Dict[str, Any]:
        """Extract CVE information from alerts
        
        Args:
            alerts: List of alert dictionaries
            
        Returns:
            Dictionary with CVE statistics and details
        """
        cve_data = {
            'total_cve_alerts': 0,
            'unique_cves': set(),
            'cve_counts': defaultdict(int),
            'cve_by_severity': {
                'critical': [],
                'high': [],
                'medium': [],
                'low': []
            },
            'cve_details': []
        }
        
        import re
        
        for alert in alerts:
            rule = alert.get('rule', {})
            description = rule.get('description', '')
            full_log = str(alert.get('full_log', ''))
            level = rule.get('level', 0)
            
            # Search for CVE patterns
            cve_pattern = r'CVE-\d{4}-\d+'
            cves_in_desc = re.findall(cve_pattern, description, re.IGNORECASE)
            cves_in_log = re.findall(cve_pattern, full_log, re.IGNORECASE)
            
            all_cves = list(set(cves_in_desc + cves_in_log))
            
            if all_cves:
                cve_data['total_cve_alerts'] += 1
                
                for cve in all_cves:
                    cve_upper = cve.upper()
                    cve_data['unique_cves'].add(cve_upper)
                    cve_data['cve_counts'][cve_upper] += 1
                    
                    # Categorize by alert level
                    severity = 'low'
                    if level >= 15:
                        severity = 'critical'
                    elif level >= 12:
                        severity = 'high'
                    elif level >= 8:
                        severity = 'medium'
                    
                    cve_data['cve_by_severity'][severity].append({
                        'cve': cve_upper,
                        'level': level,
                        'description': description[:200],  # First 200 chars
                        'rule_id': rule.get('id', 'N/A')
                    })
        
        # Convert set to list and sort
        cve_data['unique_cves'] = sorted(list(cve_data['unique_cves']))
        cve_data['total_unique_cves'] = len(cve_data['unique_cves'])
        
        # Get top CVEs
        cve_data['top_cves'] = sorted(
            cve_data['cve_counts'].items(),
            key=lambda x: x[1],
            reverse=True
        )[:20]
        
        return cve_data
    
    def get_vulnerability_trends(
        self, 
        agents: List[Dict],
        time_period_days: int = 7
    ) -> Dict[str, Any]:
        """Get vulnerability trends over time
        
        Args:
            agents: List of agent dictionaries
            time_period_days: Number of days to analyze
            
        Returns:
            Dictionary with vulnerability trend data
        """
        if not self.enabled:
            return {'enabled': False}
        
        trends = {
            'enabled': True,
            'time_period_days': time_period_days,
            'agents_trending_up': [],
            'agents_trending_down': [],
            'most_vulnerable_agents': []
        }
        
        # This would require historical data collection
        # For now, we'll provide current snapshot
        summary = self.get_vulnerability_summary(agents)
        
        trends['most_vulnerable_agents'] = summary.get(
            'vulnerabilities_by_agent', []
        )[:10]
        
        return trends
    
    def get_patch_priority_recommendations(
        self,
        agents: List[Dict]
    ) -> List[Dict[str, Any]]:
        """Get patch priority recommendations based on vulnerabilities
        
        Args:
            agents: List of agent dictionaries
            
        Returns:
            List of patch priority recommendations
        """
        if not self.enabled:
            return []
        
        recommendations = []
        summary = self.get_vulnerability_summary(agents)
        
        for agent_vuln in summary.get('vulnerabilities_by_agent', []):
            agent_id = agent_vuln['agent_id']
            agent_name = agent_vuln['agent_name']
            failed_checks = agent_vuln['total_failed_checks']
            policies = agent_vuln.get('policies', [])
            
            priority = 'low'
            if failed_checks >= 20:
                priority = 'critical'
            elif failed_checks >= 10:
                priority = 'high'
            elif failed_checks >= 5:
                priority = 'medium'
            
            # Collect policy names and details
            policy_details = []
            for policy in policies[:5]:  # Top 5 policies
                policy_name = policy.get('name', 'Unknown Policy')
                failed = policy.get('failed_checks', 0)
                passed = policy.get('passed_checks', 0)
                policy_details.append({
                    'name': policy_name,
                    'failed_checks': failed,
                    'passed_checks': passed
                })
            
            recommendations.append({
                'agent_id': agent_id,
                'agent_name': agent_name,
                'priority': priority,
                'failed_checks': failed_checks,
                'policies_affected': len(policies),
                'policy_details': policy_details,
                'recommendation': f"Review and patch {agent_name} - {failed_checks} failed security checks across {len(policies)} policy/policies"
            })
        
        # Sort by priority
        priority_order = {'critical': 0, 'high': 1, 'medium': 2, 'low': 3}
        recommendations.sort(key=lambda x: priority_order.get(x['priority'], 4))
        
        return recommendations

